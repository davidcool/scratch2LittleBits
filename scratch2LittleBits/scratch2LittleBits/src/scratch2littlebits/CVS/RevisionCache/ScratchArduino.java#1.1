/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package scratch2littlebits;

import gnu.io.CommPort;
import gnu.io.CommPortIdentifier;
import gnu.io.SerialPort;
import gnu.io.SerialPortEvent;
import gnu.io.SerialPortEventListener;
import java.io.IOException;
import java.util.Timer;
import java.util.TimerTask;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author eduardo
 */
public class ScratchArduino {

    public static final int INPUT = 0;
    public static final int OUTPUT = 1;
    public static final int ANALOG = 2;
    public static final int PWM = 3;
    public static final int SERVO = 4;
    public static final int SHIFT = 5;
    public static final int I2C = 6;
    public static final int LOW = 0;
    public static final int HIGH = 1;
    public static final int READ_PINS = 1;
    public static final int WRITE_ANALOG = 2;
    public static final int WRITE_DIGITAL = 3;
    public static final String mcsHIGH="HIGH";
    public static final String mcsLOW="LOW";

    

    public static class InputVals {

        int d0 = 0;
        int a0 = 0;
        int a1 = 0;
    }

    public static class OutputPins {

        int d1 = 1;
        int d5 = 5;
        int d9 = 9;

    }    
    
    private SerialPort serialPort;

    private int sendAttempts = 0;
    private int[] rawData = null;
    private int[] pingCmd = new int[]{1};
    private boolean connected = false;
    
    private Timer moTimer;
    
    private InputVals inputVals = new InputVals();
    private OutputPins outputPins = new OutputPins();
    
    

    public ScratchArduino(String PuertoIdent) throws IOException {
        try {
            CommPortIdentifier portIdentifier = CommPortIdentifier.getPortIdentifier(PuertoIdent);
            CommPort commPort = portIdentifier.open("little", 2000);

            if (commPort instanceof SerialPort) {
                serialPort = (SerialPort) commPort;
                //SerialPort.STOPBITS_1
                serialPort.setSerialPortParams(38400, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);
                serialPort.addEventListener(new SerialPortEventListener() {
                    public void serialEvent(SerialPortEvent e) {
                        try {
                            while (serialPort.getInputStream().available() > 0) {
                                int n = serialPort.getInputStream().read();

                                sendAttempts = 0;

                                if (rawData == null || rawData.length == 3) {
                                    rawData = new int[]{n};
                                } else {
                                    rawData = appendBuffer(rawData, n);
                                }

                                if (rawData.length >= 3) {
                                    processData();
                                }

                            }
                        } catch (Exception err) {
                            err.printStackTrace();
                        }
                    }
                });
                serialPort.notifyOnDataAvailable(true);

                try {
                    Thread.sleep(3000); // let bootloader timeout
                } catch (InterruptedException e) {
                }

            } else {
                System.out.println("Error: Only serial ports are handled by this example.");
                return;
            }

            moTimer = new Timer();
            moTimer.schedule(new TimerTask() {
                @Override
                public void run() {
                    try {
                        /* TEMPORARY WORKAROUND
                                                    Since _deviceRemoved is not
                                                    called while using serial devices */
                        if (sendAttempts >= 10) {
                            close();
                            return;
                        }

                        write(pingCmd);
                        sendAttempts++;
                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }
                }
            }, 50);
        } catch (Exception e) {
            System.out.println(e);
            return;
        }
    }

    public void close() {
        if (serialPort != null) {
            serialPort.close();
            serialPort = null;
            
        }
        if (moTimer != null) {
            moTimer.cancel();
            moTimer = null;
        }
        connected = false;
        rawData=null;
    }

    private void processData() {
        inputVals.d0 = rawData[0];
        inputVals.a0 = rawData[1];
        inputVals.a1 = rawData[2];
        rawData = null;
    }
    
    private int[] appendBuffer(int[] buffer1, int buffer2) {
        int[] tmp = new int[buffer1.length + 1];
        System.arraycopy(buffer1, 0, tmp, 0, buffer1.length);
        tmp[buffer1.length] = buffer2;
        return tmp;
    }

    public void write(int[] b) throws IOException {
        for(int i = 0; i < b.length; i++){
            serialPort.getOutputStream().write(b[i]);
        }
    }

    public int analogRead(int pin) {
        int lResult = 0;
        switch (pin) {
            case 0:
                lResult = inputVals.d0;
                break;
            case 1:
                lResult = inputVals.a0;
                break;
            case 2:
                lResult = inputVals.a1;
                break;
        }
        return lResult;
    }

    public boolean digitalRead(int pin) {
        if (analogRead(pin) > 0) {
            return true;
        }
        return false;
    }

    public void analogWrite(int pin, int val) throws IOException {
        int[] output = new int[3];
        output[0] = 2;
        switch (pin) {
            case 0:
                output[1] = outputPins.d1;
                break;
            case 1:
                output[1] = outputPins.d5;
                break;
            case 2:
                output[1] = outputPins.d9;
                break;
        }
        output[2] = val;
        write(output);
    }
    public void analogWrite(String pin, int val) throws IOException {
        if(pin.equalsIgnoreCase("d1")){
            analogWrite(0, val);
        }else if(pin.equalsIgnoreCase("d5")){
            analogWrite(1, val);
        }else if(pin.equalsIgnoreCase("d9")){
            analogWrite(2, val);
        }
    }
    public void digitalWrite(String pin, String val) throws IOException {
        if(pin.equalsIgnoreCase("d1")){
            digitalWrite(0, val);
        }else if(pin.equalsIgnoreCase("d5")){
            digitalWrite(1, val);
        }else if(pin.equalsIgnoreCase("d9")){
            digitalWrite(2, val);
        }
    }

    public void digitalWrite(int pin, String val) throws IOException {
        int[] output = new int[3];
        output[0] = 3;

        switch (pin) {
            case 0:
                output[1] = outputPins.d1;
                break;
            case 1:
                output[1] = outputPins.d5;
                break;
            case 2:
                output[1] = outputPins.d9;
                break;
        }
        if (val.equals(mcsHIGH)) {
            output[2] = 1;
        } else {
            output[2] = 0;
        }
        write(output);
    }

    public boolean whenAnalogRead(int pin, char op, int val) {
        if (op == '>') {
            return analogRead(pin) > val;
        } else if (op == '<') {
            return analogRead(pin) < val;
        } else if (op == '=') {
            return analogRead(pin) == val;
        } else {
            return false;
        }
    }

    public boolean whenDigitalRead(int pin, String val) {
        if (val.equalsIgnoreCase("HIGH")) {
            return digitalRead(pin);
        } else {
            return digitalRead(pin) == false;
        }
    }
    public InputVals getInputVals(){
        return inputVals;
    }
    public OutputPins getOutputPins(){
        return outputPins;
    }
    public void resetAll() throws IOException {
        analogWrite(1, 0);
        analogWrite(2, 0);
        digitalWrite(0, mcsLOW);
//        inputVals.a0=0;
//        inputVals.a1=0;
//        inputVals.d0=0;
        
    }
    
}
