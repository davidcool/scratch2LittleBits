/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package scratch2littlebits;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author eduardo
 */
public class ScratchHttp implements Runnable{
    private static final int PORT = 40000; // set to your extension's port number
    private static InputStream sockIn;
    private static OutputStream sockOut;
    private final Scratch2LittleBits moControl;

    public ScratchHttp(Scratch2LittleBits poControl){
        moControl=poControl;
    }
    
    @Override
    public void run() {

        try {
            InetAddress addr = InetAddress.getLocalHost();
            System.out.println("HTTPExtensionExample helper app started on " + addr.toString());
            
            ServerSocket serverSock = new ServerSocket(PORT);
            while (true) {
                Socket sock = serverSock.accept();
                sockIn = sock.getInputStream();
                sockOut = sock.getOutputStream();
                try {
                    handleRequest();
                } catch (Exception e) {
                    e.printStackTrace();
                    sendResponse("unknown server error");
                }
                sock.close();
            }
        } catch (Throwable  ex) {
            Logger.getLogger(ScratchHttp.class.getName()).log(Level.SEVERE, null, ex);    
        }
    }

    private  void handleRequest() throws IOException {
        String httpBuf = "";
        int i;

// read data until the first HTTP header line is complete (i.e. a '\n' is seen)
        while ((i = httpBuf.indexOf('\n')) < 0) {
            byte[] buf = new byte[5000];
            int bytes_read = sockIn.read(buf, 0, buf.length);
            if (bytes_read < 0) {
                System.out.println("Socket closed; no HTTP header.");
                return;
            }
            httpBuf += new String(Arrays.copyOf(buf, bytes_read));
        }

        String header = httpBuf.substring(0, i);
        if (header.indexOf("GET ") != 0) {
            System.out.println("This server only handles HTTP GET requests.");
            return;
        }
        i = header.indexOf("HTTP/1");
        if (i < 0) {
            System.out.println("Bad HTTP GET header.");
            return;
        }
        header = header.substring(5, i - 1);
        if (header.equals("favicon.ico")) {
            return; // igore browser favicon.ico requests
        } else if (header.equals("crossdomain.xml")) {
            sendPolicyFile();
        } else if (header.length() == 0) {
            doHelp();
        } else {
            doCommand(header);
        }
    }

    private  void sendPolicyFile() {
// Send a Flash null-teriminated cross-domain policy file.
        String policyFile
                = "<cross-domain-policy>\n"
                + " <allow-access-from domain=\"*\" to-ports=\"" + PORT + "\"/>\n"
                + "</cross-domain-policy>\n\0";
        sendResponse(policyFile);
    }

    private  void sendResponse(String s) {
        String crlf = "\r\n";
        String httpResponse = "HTTP/1.1 200 OK" + crlf;
        httpResponse += "Content-Type: text/html; charset=ISO-8859-1" + crlf;
        httpResponse += "Access-Control-Allow-Origin: *" + crlf;
        httpResponse += crlf;
        httpResponse += s + crlf;
        try {
            byte[] outBuf = httpResponse.getBytes();
            sockOut.write(outBuf, 0, outBuf.length);
        } catch (Exception ignored) {
        }
    }

    private void doHelp() {
// Optional: return a list of commands understood by this server
        String help = "Servidor HTTP Extension LittleBits<br><br>";
        sendResponse(help);
    }

    private void doCommand(String header) {
        try{
            if(moControl.getArduino()!=null){
                if(header.equalsIgnoreCase("poll")){
                    sendResponse(""
                            + "a0 " + String.valueOf((int)moControl.getArduino().getInputVals().a0)+Character.toString((char)10)
                            + "a1 " + String.valueOf((int)moControl.getArduino().getInputVals().a1)+Character.toString((char)10)
                            + "d0 " + String.valueOf((int)moControl.getArduino().getInputVals().d0)+Character.toString((char)10)
                    );
                }else if(header.equalsIgnoreCase("reset_all")){
                    moControl.getArduino().resetAll();
                    sendResponse("ok");
                }else {
                    String[] las = header.split("/");
                    if(las[0].equalsIgnoreCase("digitalWrite")){
                        moControl.getArduino().digitalWrite(las[1], las[2]);
                    }else if(las[0].equalsIgnoreCase("analogWrite")){
                        moControl.getArduino().analogWrite(las[1], Integer.valueOf(las[2]).intValue());
                    } else{
                        System.out.println("Comando no procesado: " + header);
                    }
                    sendResponse("ok");
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            sendResponse("error:"+e.toString());
        }        
    }

    
}
